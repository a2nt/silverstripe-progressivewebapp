{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./client/src/sw.js","webpack:///./client/src/thirdparty/serviceworker-caches.js"],"names":["caches","require","self","CACHE_NAME","Error","addEventListener","event","fetchRequest","request","clone","cacheRequest","respondWith","fetch","then","response","responseToCache","open","cache","cacheSaveRequest","put","catch","err","match","waitUntil","delete","Cache","prototype","add","addAll","requests","NetworkError","message","name","code","Object","create","Promise","resolve","arguments","length","TypeError","sequence","map","Request","String","all","scheme","URL","url","protocol","responses","i","undefined","CacheStorage","opts","keys","cacheNames","reduce","chain","cacheName","module","exports"],"mappings":"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","file":"sw.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/mnt/data/srv/dist/web/nysca/vendor/a2nt/silverstripe-progressivewebapp/client/dist\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./client/src/sw.js\");\n","// caches polyfill because it is not added to native yet!\nvar caches = require('./thirdparty/serviceworker-caches');\n\nif (typeof self.CACHE_NAME !== 'string') {\n  throw new Error('Cache Name cannot be empty');\n}\n\nself.addEventListener('fetch', (event) => {\n  // Clone the request for fetch and cache\n  // A request is a stream and can be consumed only once.\n  var fetchRequest = event.request.clone(),\n    cacheRequest = event.request.clone();\n\n  // Respond with content from fetch or cache\n  event.respondWith(\n    // Try fetch\n    fetch(fetchRequest)\n      // when fetch is successful, we update the cache\n      .then((response) => {\n        // A response is a stream and can be consumed only once.\n        // Because we want the browser to consume the response,\n        // as well as cache to consume the response, we need to\n        // clone it so we have 2 streams\n        var responseToCache = response.clone();\n\n        // and update the cache\n        caches.open(self.CACHE_NAME).then((cache) => {\n          // Clone the request again to use it\n          // as the key for our cache\n          var cacheSaveRequest = event.request.clone();\n          cache.put(cacheSaveRequest, responseToCache);\n        });\n\n        // Return the response stream to be consumed by browser\n        return response;\n      })\n\n      // when fetch times out or fails\n      .catch((err) => {\n        // Return the promise which\n        // resolves on a match in cache for the current request\n        // or rejects if no matches are found\n        return caches.match(cacheRequest);\n      }),\n  );\n});\n\n// Now we need to clean up resources in the previous versions\n// of Service Worker scripts\nself.addEventListener('activate', (event) => {\n  // Destroy the cache\n  event.waitUntil(caches.delete(self.CACHE_NAME));\n});\n","if (!Cache.prototype.add) {\n  Cache.prototype.add = function add(request) {\n    return this.addAll([request]);\n  };\n}\n\nif (!Cache.prototype.addAll) {\n  Cache.prototype.addAll = function addAll(requests) {\n    var cache = this;\n\n    // Since DOMExceptions are not constructable:\n    function NetworkError(message) {\n      this.name = 'NetworkError';\n      this.code = 19;\n      this.message = message;\n    }\n    NetworkError.prototype = Object.create(Error.prototype);\n\n    return Promise.resolve()\n      .then(function() {\n        if (arguments.length < 1) throw new TypeError();\n\n        // Simulate sequence<(Request or USVString)> binding:\n        var sequence = [];\n\n        requests = requests.map((request) => {\n          if (request instanceof Request) {\n            return request;\n          } else {\n            return String(request); // may throw TypeError\n          }\n        });\n\n        return Promise.all(\n          requests.map((request) => {\n            if (typeof request === 'string') {\n              request = new Request(request);\n            }\n\n            var scheme = new URL(request.url).protocol;\n\n            if (scheme !== 'http:' && scheme !== 'https:') {\n              throw new NetworkError('Invalid scheme');\n            }\n\n            return fetch(request.clone());\n          }),\n        );\n      })\n      .then((responses) => {\n        // TODO: check that requests don't overwrite one another\n        // (don't think this is possible to polyfill due to opaque responses)\n        return Promise.all(\n          responses.map((response, i) => {\n            return cache.put(requests[i], response);\n          }),\n        );\n      })\n      .then(() => {\n        return undefined;\n      });\n  };\n}\n\nif (!CacheStorage.prototype.match) {\n  // This is probably vulnerable to race conditions (removing caches etc)\n  CacheStorage.prototype.match = function match(request, opts) {\n    var caches = this;\n\n    return this.keys().then((cacheNames) => {\n      var match;\n\n      return cacheNames.reduce((chain, cacheName) => {\n        return chain.then(() => {\n          return (\n            match ||\n            caches\n              .open(cacheName)\n              .then((cache) => {\n                return cache.match(request, opts);\n              })\n              .then((response) => {\n                match = response;\n                return match;\n              })\n          );\n        });\n      }, Promise.resolve());\n    });\n  };\n}\n\nmodule.exports = self.caches;\n"],"sourceRoot":""}